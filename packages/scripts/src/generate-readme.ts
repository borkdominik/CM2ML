import { writeFile } from 'node:fs/promises'
import process from 'node:process'

import type { Package } from '@manypkg/get-packages'
import { getPackages } from '@manypkg/get-packages'

const disclaimer = '<!-- DO NOT EDIT THIS FILE MANUALLY. USE THE `generate-readme` SCRIPT AND SEE packages/scripts/src/generate-readme.ts. -->'

const installation = `## Installation

### Library

The entire CM2ML framework is available via the \`@cm2ml/cm2ml\` package.
This includes all modules, as well as the CLI and REST adapters.

\`\`\`bash
npm install @cm2ml/cm2ml
\`\`\`

### Library (Browser)

The \`@cm2ml/builtin\` package may be used in the browser, as it does not include the CLI and REST server.
Parser and encoder authors may also install \`@cm2ml/plugin\`, \`@cm2ml/ir\`.
Authors of adapters may install \`@cm2ml/plugin-adapter\`.

\`\`\`bash
npm install @cm2ml/builtin @cm2ml/plugin @cm2ml/plugin-adapter @cm2ml/ir
\`\`\`

### CLI

\`\`\`bash
npm install -g @cm2ml/cli

cm2ml -h
\`\`\`

### REST Server

\`\`\`bash
npm install -g @cm2ml/server

cm2ml-server
\`\`\``

const development = `## Development

Enable corepack with \`corepack enable\` to automate the installation and selection of the correct package manager.
Dependencies may be installed via \`pnpm install\`.
This monorepo uses Turborepo to orchestrate task execution.
The \`build\`, \`test\`, \`lint\`, and \`typecheck\` tasks are available in all packages.
The \`turbo\` package script may be used to execute tasks as required.

The \`ci\` and \`ci:full\` package scripts execute all tasks, with the latter including E2E tests.

### Testing

The locally built CLI and REST server may be started via the \`cm2ml\` and \`server\` package scripts.

### Releasing

To create a release, run the \`changeset\` package script.
This will guide you through the process of creating a changeset.
Next, commit the changeset and push to the main branch.
The CI will create a pull request for the release that must be merged to publish the packages.`

export async function generateReadme() {
  const { packages, rootPackage } = await getPackages(process.cwd())
  const header = createHeader(rootPackage)
  const packageList = createPackageList(packages)
  const body = [header, installation, packageList, development].join('\n\n')
  await writeFile('README.md', `${disclaimer}\n${body}\n`)
}

function createHeader(rootPackage: Package | undefined) {
  if (!rootPackage) {
    return ''
  }
  const name = rootPackage.packageJson.name
  const homepage = (rootPackage.packageJson as any).homepage ?? ''
  const description = (rootPackage.packageJson as any).description ?? ''
  return `# ${name}\n\n> Visualizer: <${homepage}>\n\n> ${description}`
}

function createPackageList(packages: Package[]) {
  const packagesByType = groupBy(packages, (pkg) => {
    const dirs = pkg.relativeDir.split('/')
    const fallback = 'other'
    if (dirs.length < 3) {
      return fallback
    }
    return dirs[1] ?? fallback
  })
  const packageList = Object.entries(packagesByType)
    .sort(([a], [b]) => {
      if (a === 'other') {
        return 1
      }
      if (b === 'other') {
        return -1
      }
      return a.localeCompare(b)
    })
    .map(([type, pkgs]) => createSection(type, pkgs))
    .join('\n\n')
  return `## Packages\n\n${packageList}`
}

function createSection(type: string, pkgs: Package[]) {
  const packageLines = pkgs
    .sort((a, b) => a.packageJson.name.localeCompare(b.packageJson.name))
    .map(createPackageLine)
    .join('\n')
  return `### ${toTypeHeader(type)}\n\n${packageLines}`
}

function toTypeHeader(type: string) {
  const segments = type.split('-')
  return segments.map((segment) => segment[0]!.toUpperCase() + segment.slice(1)).join(' ')
}

function createPackageLine(pkg: Package) {
  const url = `./${pkg.relativeDir}`
  return `- [${pkg.packageJson.name}](${url})`
}

function groupBy<T>(items: T[], key: (item: T) => string): Record<string, T[]> {
  return items.reduce(
    (acc, item) => {
      const group = key(item)
      if (!acc[group]) {
        acc[group] = []
      }
      acc[group]?.push(item)
      return acc
    },
    {} as Record<string, T[]>,
  )
}
